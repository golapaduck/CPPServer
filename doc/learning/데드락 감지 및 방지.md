# 데드락 감지 및 방지

## 데드락(Deadlock)이란?

데드락(Deadlock)은 두 개 이상의 스레드가 서로 상대방이 점유하고 있는 자원을 기다리며 무한정 대기하는 상태를 말합니다. 이러한 상황은 멀티스레드 프로그래밍에서 흔히 발생할 수 있는 문제로, 프로그램이 더 이상 진행되지 않고 멈추게 됩니다.

## 데드락 발생 조건

데드락이 발생하기 위해서는 다음 네 가지 조건이 모두 충족되어야 합니다:

1. **상호 배제(Mutual Exclusion)**: 자원은 한 번에 하나의 프로세스만 사용할 수 있습니다.
2. **점유 대기(Hold and Wait)**: 프로세스가 이미 자원을 점유한 상태에서 다른 자원을 기다립니다.
3. **비선점(Non-preemption)**: 다른 프로세스에 할당된 자원은 사용이 끝날 때까지 강제로 빼앗을 수 없습니다.
4. **순환 대기(Circular Wait)**: 프로세스의 집합에서 순환 형태로 서로가 서로의 자원을 기다리는 상황이 발생합니다.

## 데드락 예방 기법

데드락을 예방하기 위해 위의 네 가지 조건 중 하나 이상을 제거하는 방법을 사용할 수 있습니다:

1. **상호 배제 조건 제거**: 모든 프로세스가 자원을 공유할 수 있도록 합니다. 그러나 이는 자원의 특성상 불가능한 경우가 많습니다.
2. **점유 대기 조건 제거**: 프로세스가 실행되기 전에 필요한 모든 자원을 할당받거나, 자원이 필요할 때 보유하고 있는 자원을 모두 해제한 후 다시 요청합니다.
3. **비선점 조건 제거**: 자원을 점유하고 있는 프로세스로부터 자원을 빼앗을 수 있게 합니다.
4. **순환 대기 조건 제거**: 자원에 번호를 부여하고 오름차순으로만 자원을 요청하도록 합니다.

## 데드락 감지 및 회복

데드락을 예방하는 것이 항상 가능하지 않기 때문에, 데드락을 감지하고 회복하는 방법도 중요합니다:

1. **데드락 감지**: 자원 할당 그래프(Resource Allocation Graph)를 사용하여 순환 의존성을 찾습니다.
2. **데드락 회복**: 감지된 데드락을 해결하기 위해 프로세스를 종료하거나 자원을 선점합니다.

## C++에서의 데드락 감지 및 방지

C++에서는 다양한 방법으로 데드락을 방지하고 감지할 수 있습니다:

### 1. 락 계층 구조 사용

락에 계층 구조를 부여하고, 항상 낮은 계층에서 높은 계층 순으로 락을 획득하도록 합니다. 이렇게 하면 순환 대기 조건을 제거할 수 있습니다.

```cpp
// 락 계층 예시
enum class LockLevel {
    LOW = 0,
    MEDIUM = 1,
    HIGH = 2
};

class HierarchicalMutex {
private:
    std::mutex mtx;
    LockLevel level;
    static thread_local LockLevel currentLevel;
    
public:
    HierarchicalMutex(LockLevel level) : level(level) {}
    
    void lock() {
        if (currentLevel <= level) {
            throw std::logic_error("Lock hierarchy violated");
        }
        mtx.lock();
        currentLevel = level;
    }
    
    void unlock() {
        currentLevel = LockLevel::HIGH;
        mtx.unlock();
    }
};
```

### 2. std::lock 사용

C++ 표준 라이브러리의 `std::lock` 함수는 여러 뮤텍스를 동시에 락하면서 데드락을 방지합니다.

```cpp
std::mutex mtx1, mtx2;

void safe_function() {
    std::lock(mtx1, mtx2); // 데드락 없이 두 뮤텍스를 모두 락
    std::lock_guard<std::mutex> lock1(mtx1, std::adopt_lock);
    std::lock_guard<std::mutex> lock2(mtx2, std::adopt_lock);
    
    // 안전하게 공유 자원에 접근
}
```

### 3. std::scoped_lock 사용 (C++17 이상)

C++17에서 도입된 `std::scoped_lock`은 여러 뮤텍스를 RAII 방식으로 관리하면서 데드락을 방지합니다.

```cpp
std::mutex mtx1, mtx2;

void safe_function() {
    std::scoped_lock lock(mtx1, mtx2); // 데드락 없이 두 뮤텍스를 모두 락
    
    // 안전하게 공유 자원에 접근
}
```

### 4. 데드락 감지기(DeadLock Profiler) 구현

런타임에 데드락을 감지하기 위한 프로파일러를 구현할 수 있습니다. 이는 락 획득 순서를 추적하고 순환 의존성이 발생하는지 확인합니다.

```cpp
class DeadLockProfiler {
private:
    std::unordered_map<const char*, int> nameToId;
    std::unordered_map<int, const char*> idToName;
    std::stack<int> lockStack;
    std::map<int, std::set<int>> lockHistory;
    std::mutex lock;
    
    // 순환 감지를 위한 변수들
    std::vector<int> discoveredOrder;
    int discoveredCount;
    std::vector<bool> finished;
    std::vector<int> parent;
    
public:
    void PushLock(const char* name);
    void PopLock(const char* name);
    void CheckCycle();
    
private:
    void Dfs(int here);
};
```

## 읽기-쓰기 스핀락(RW SpinLock)

읽기-쓰기 락은 여러 스레드가 동시에 읽기 작업을 수행할 수 있지만, 쓰기 작업은 배타적으로 수행되도록 하는 동기화 메커니즘입니다. 스핀락은 락을 획득할 때까지 계속해서 시도하는 방식으로, 대기 시간이 짧을 때 효율적입니다.

### RW SpinLock 구현

```cpp
class RWSpinLock {
private:
    std::atomic<uint32_t> lockFlag;
    
    enum : uint32_t {
        WRITE_THREAD_MASK = 0xFFFF0000,
        READ_COUNT_MASK = 0x0000FFFF,
        EMPTY_FLAG = 0x00000000
    };
    
public:
    RWSpinLock() : lockFlag(EMPTY_FLAG) {}
    
    void ReadLock() {
        uint32_t expected;
        uint32_t desired;
        
        do {
            expected = lockFlag.load(std::memory_order_relaxed) & ~WRITE_THREAD_MASK;
            desired = expected + 1;
        } while (!lockFlag.compare_exchange_weak(expected, desired, 
                                               std::memory_order_acquire,
                                               std::memory_order_relaxed));
    }
    
    void ReadUnlock() {
        lockFlag.fetch_sub(1, std::memory_order_release);
    }
    
    void WriteLock() {
        uint32_t expected = EMPTY_FLAG;
        uint32_t desired = (GetCurrentThreadId() << 16) & WRITE_THREAD_MASK;
        
        while (!lockFlag.compare_exchange_weak(expected, desired,
                                             std::memory_order_acquire,
                                             std::memory_order_relaxed)) {
            expected = EMPTY_FLAG;
            std::this_thread::yield();
        }
    }
    
    void WriteUnlock() {
        lockFlag.store(EMPTY_FLAG, std::memory_order_release);
    }
};
```

## RAII 패턴을 이용한 락 관리

RAII(Resource Acquisition Is Initialization) 패턴을 사용하면 자원의 획득과 해제를 객체의 생성과 소멸에 연결하여 안전하게 관리할 수 있습니다.

```cpp
class ReadLockGuard {
private:
    RWSpinLock& lock;
    
public:
    ReadLockGuard(RWSpinLock& lock) : lock(lock) {
        lock.ReadLock();
    }
    
    ~ReadLockGuard() {
        lock.ReadUnlock();
    }
};

class WriteLockGuard {
private:
    RWSpinLock& lock;
    
public:
    WriteLockGuard(RWSpinLock& lock) : lock(lock) {
        lock.WriteLock();
    }
    
    ~WriteLockGuard() {
        lock.WriteUnlock();
    }
};
```

## 결론

데드락은 멀티스레드 프로그래밍에서 발생할 수 있는 심각한 문제입니다. 데드락을 방지하기 위해 락 계층 구조 사용, 표준 라이브러리의 데드락 방지 기능 활용, 데드락 감지기 구현 등의 방법을 사용할 수 있습니다. 또한 읽기-쓰기 락과 RAII 패턴을 함께 사용하면 더욱 안전하고 효율적인 멀티스레드 프로그래밍이 가능합니다.
