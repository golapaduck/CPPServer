# 메모리 풀 (Memory Pool)

## 개요

메모리 풀은 동적 메모리 할당 및 해제 작업을 최적화하기 위한 메모리 관리 기법입니다. 특히 게임 서버와 같이 성능이 중요한 애플리케이션에서 자주 사용됩니다. 메모리 풀은 미리 일정 크기의 메모리 블록을 할당해두고, 필요할 때마다 이 블록을 재사용함으로써 반복적인 메모리 할당/해제 작업의 오버헤드를 줄입니다.

## 메모리 풀의 필요성

### 일반적인 동적 메모리 할당의 문제점

1.  **성능 오버헤드**: `new`/`delete` 또는 `malloc`/`free` 같은 동적 메모리 할당 함수는 내부적으로 복잡한 작업을 수행하며, 이는 성능 저하를 가져올 수 있습니다.
2.  **메모리 단편화**: 반복적인 할당과 해제는 메모리 단편화를 일으킬 수 있어, 사용 가능한 메모리가 충분해도 큰 블록을 할당하지 못하는 상황이 발생할 수 있습니다.
3.  **캐시 효율성 저하**: 무작위로 할당된 메모리는 캐시 지역성(locality)을 해치며, 이는 성능 저하로 이어집니다.

### 메모리 풀의 장점

1.  **빠른 할당 및 해제**: 미리 할당된 메모리 블록을 사용하므로 할당/해제 작업이 매우 빠릅니다.
2.  **메모리 단편화 감소**: 동일한 크기의 블록을 관리하므로 외부 단편화가 발생하지 않습니다.
3.  **캐시 효율성 향상**: 메모리 블록이 연속적으로 위치할 가능성이 높아 캐시 지역성이 향상됩니다.
4.  **예측 가능한 성능**: 메모리 할당/해제 시간이 일정하여 성능 예측이 용이합니다.

## 구현 방식

### 기본 구조

메모리 풀은 일반적으로 다음과 같은 구성 요소를 가집니다:

1.  **메모리 블록 컨테이너**: 미리 할당된 메모리 블록들을 관리하는 자료구조
2.  **메모리 헤더**: 각 메모리 블록의 메타데이터를 저장하는 구조체
3.  **할당/해제 인터페이스**: 메모리 블록을 할당하고 해제하는 함수

### Windows에서의 구현 (SLIST 활용)

윈도우 환경에서는 `SLIST`(Single-Linked List) 자료구조를 활용하여 메모리 풀을 효율적으로 구현할 수 있습니다. `SLIST`는 윈도우 API에서 제공하는 락-프리(lock-free) 단일 연결 리스트로, 멀티스레드 환경에서 안전하게 사용할 수 있습니다.

**중요**: `SLIST_ENTRY`를 사용하는 모든 리스트 아이템은 `MEMORY_ALLOCATION_ALIGNMENT` 경계에 정렬되어야 합니다. 정렬되지 않은 아이템은 예기치 않은 동작을 유발할 수 있으므로, 메모리 할당 시 `_aligned_malloc`과 같은 정렬된 메모리 할당 함수를 사용해야 합니다. `SLIST_ALIGNMENT` 상수는 이러한 정렬 요구사항을 반영합니다.

```cpp
// 필요한 헤더
#include <windows.h>
#include <malloc.h> // _aligned_malloc, _aligned_free
#include <new>      // placement new
#include <atomic>   // std::atomic

// SLIST 정렬 요구사항 (일반적으로 16바이트)
// 64비트 시스템에서는 MEMORY_ALLOCATION_ALIGNMENT가 16임
// SLIST_ENTRY 구조체 자체가 이 정렬을 강제하지 않으므로 명시적 정렬 필요
#ifndef SLIST_ALIGNMENT
#define SLIST_ALIGNMENT MEMORY_ALLOCATION_ALIGNMENT
#endif

// 메모리 헤더 구조체 (SLIST_ALIGNMENT에 맞춰 정렬)
DECLSPEC_ALIGN(SLIST_ALIGNMENT)
struct MemoryHeader : public SLIST_ENTRY
{
    MemoryHeader(int32 size) : allocSize(size) { }
    
    // 메모리 블록에 헤더 추가
    static void* AttachHeader(MemoryHeader* header, int32 size)
    {
        new(header)MemoryHeader(size); // placement new
        return reinterpret_cast<void*>(++header);
    }
    
    // 메모리 블록에서 헤더 분리
    static MemoryHeader* DetachHeader(void* ptr)
    {
        MemoryHeader* header = reinterpret_cast<MemoryHeader*>(ptr) - 1;
        return header;
    }
    
    int32 allocSize; // 할당된 메모리 크기
};

// 메모리 풀 클래스 (SLIST_ALIGNMENT에 맞춰 정렬)
DECLSPEC_ALIGN(SLIST_ALIGNMENT)
class MemoryPool
{
public:
    MemoryPool(int32 allocSize) : _allocSize(allocSize)
    {
        ::InitializeSListHead(&_header);
    }
    
    ~MemoryPool()
    {
        // 남은 모든 메모리 블록 해제
        while (MemoryHeader* memory = static_cast<MemoryHeader*>(::InterlockedPopEntrySList(&_header)))
            ::_aligned_free(memory); // 정렬된 메모리 해제
    }
    
    // 메모리 블록을 풀에 반환
    void Push(MemoryHeader* ptr)
    {
        // SLIST_ENTRY는 반드시 정렬되어야 함
        ::InterlockedPushEntrySList(&_header, static_cast<PSLIST_ENTRY>(ptr));
        _allocCount.fetch_sub(1);
    }
    
    // 메모리 블록을 풀에서 가져오기
    MemoryHeader* Pop()
    {
        MemoryHeader* memory = static_cast<MemoryHeader*>(::InterlockedPopEntrySList(&_header));
        
        // 풀에 가용한 메모리 블록이 없으면 새로 할당 (정렬된 메모리로)
        if (memory == nullptr)
        {
            memory = reinterpret_cast<MemoryHeader*>(::_aligned_malloc(_allocSize, SLIST_ALIGNMENT));
        }
        
        _allocCount.fetch_add(1);
        return memory;
    }
    
private:
    SLIST_HEADER _header;       // SLIST 헤더
    int32 _allocSize = 0;       // 할당 크기
    std::atomic<int32> _allocCount = 0; // 현재 할당된 블록 수
};
```

## 메모리 풀 사용 예제

```cpp
// 메모리 풀 생성 (각 블록 크기: 1024 바이트)
MemoryPool pool(1024);

// 메모리 할당
void* memory = MemoryHeader::AttachHeader(pool.Pop(), 1024);

// 메모리 사용
// ...

// 메모리 해제
MemoryHeader* header = MemoryHeader::DetachHeader(memory);
pool.Push(header);
```

## 메모리 풀 사용 시 주의사항

1.  **크기 제한**: 메모리 풀은 동일한 크기의 블록만 관리하므로, 다양한 크기의 메모리가 필요한 경우 여러 개의 메모리 풀을 사용해야 합니다.
2.  **메모리 누수**: 사용이 끝난 메모리 블록을 풀에 반환하지 않으면 메모리 누수가 발생합니다.
3.  **스레드 안전성**: 멀티스레드 환경에서 사용할 경우 적절한 동기화 메커니즘이 필요합니다. Windows SLIST는 이미 스레드 안전하게 설계되어 있습니다.
4.  **메모리 정렬**: 특정 하드웨어 아키텍처에서는 메모리 정렬이 중요할 수 있으므로, 정렬 요구사항을 고려해야 합니다. 특히 `SLIST_ENTRY`를 사용할 때는 `MEMORY_ALLOCATION_ALIGNMENT`에 맞춰 정렬된 메모리(`_aligned_malloc` 사용)를 사용해야 합니다.

## 결론

메모리 풀은 성능이 중요한 애플리케이션, 특히 게임 서버와 같이 실시간 처리가 필요한 시스템에서 매우 유용한 메모리 관리 기법입니다. 적절히 구현하면 메모리 할당/해제 오버헤드를 크게 줄이고, 애플리케이션의 전반적인 성능을 향상시킬 수 있습니다. 하지만 사용 시 주의사항을 잘 고려하여 구현해야 합니다.
