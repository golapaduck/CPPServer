# 메모리 관리와 스마트 포인터

## 개요

C++에서 메모리 관리는 프로그램의 성능과 안정성에 매우 중요한 요소입니다. 이 문서에서는 게임 서버에서 사용되는 메모리 관리 기법과 스마트 포인터 구현에 대해 설명합니다.

## 메모리 할당자 (Allocator)

### BaseAllocator

기본적인 메모리 할당 인터페이스를 제공합니다.

```cpp
class BaseAllocator
{
public:
    static void* Alloc(int32 size);
    static void  Release(void* ptr);
};
```

- `Alloc(size)`: 지정된 크기의 메모리를 할당합니다.
- `Release(ptr)`: 할당된 메모리를 해제합니다.

### StompAllocator

디버깅을 위한 특수 메모리 할당자입니다. 메모리 오버플로우나 언더플로우를 감지하는 데 도움이 됩니다.

```cpp
class StompAllocator
{
    enum { PAGE_SIZE = 0x1000 };
public:
    static void* Alloc(int32 size);
    static void  Release(void* ptr);
};
```

- 페이지 단위로 메모리를 할당하여 경계를 넘어서는 메모리 접근을 감지할 수 있습니다.
- 디버그 모드에서 메모리 문제를 조기에 발견하는 데 유용합니다.

### StlAllocator

STL 컨테이너에서 사용할 수 있는 사용자 정의 할당자입니다.

```cpp
template<typename T>
class StlAllocator
{
public:
    using value_type = T;
    
    // 생성자 및 복사 생성자
    StlAllocator() { }
    template<typename Other>
    StlAllocator(const StlAllocator<Other>&) { }
    
    // 메모리 할당 및 해제 함수
    T* allocate(size_t count)
    {
        const int32 size = static_cast<int32>(count * sizeof(T));
        return static_cast<T*>(xalloc(size));
    }
    
    void deallocate(T* ptr, size_t count)
    {
        xrelease(ptr);
    }
};
```

- STL 컨테이너의 메모리 할당 방식을 커스터마이징할 수 있습니다.
- 프로젝트의 메모리 할당 정책을 일관되게 적용할 수 있습니다.

## 메모리 유틸리티 함수

### xnew와 xdelete

사용자 정의 new와 delete 연산자입니다.

```cpp
template<typename Type, typename... Args>
Type* xnew(Args&&... args)
{
    Type* memory = static_cast<Type*>(xalloc(sizeof(Type)));
    new(memory) Type(forward<Args>(args)...);  // placement new
    return memory;
}

template<typename Type>
void xdelete(Type* obj)
{
    obj->~Type();
    xrelease(obj);
}
```

- `xnew`: 메모리를 할당하고 객체를 생성합니다. placement new를 사용합니다.
- `xdelete`: 객체의 소멸자를 호출하고 메모리를 해제합니다.

### xalloc과 xrelease 매크로

메모리 할당 및 해제를 위한 매크로입니다.

```cpp
#ifdef _DEBUG
#define xalloc(size)        StompAllocator::Alloc(size)
#define xrelease(ptr)       StompAllocator::Release(ptr)
#else
// 릴리스 모드에서는 다른 할당자를 사용할 수 있음
#endif
```

- 디버그 모드에서는 `StompAllocator`를 사용하여 메모리 문제를 감지합니다.
- 릴리스 모드에서는 성능에 최적화된 다른 할당자를 사용할 수 있습니다.

## 참조 카운팅 (Reference Counting)

### RefCountable

참조 카운팅 기능을 제공하는 기본 클래스입니다.

```cpp
class RefCountable
{
public:
    RefCountable() : _refCount(1) { }
    virtual ~RefCountable() { }
    
    int32 GetRefCount() { return _refCount; }
    
    int32 AddRef() { return ++_refCount; }
    int32 ReleaseRef()
    {
        int32 refCount = --_refCount;
        if (refCount == 0)
        {
            delete this;
        }
        return refCount;
    }
    
protected:
    atomic<int32> _refCount;
};
```

- 객체의 참조 횟수를 추적합니다.
- 참조 횟수가 0이 되면 자동으로 객체를 삭제합니다.
- `atomic<int32>`를 사용하여 스레드 안전성을 보장합니다.

### SharedPtr

참조 카운팅 기반의 스마트 포인터입니다.

```cpp
template<typename T>
class SharedPtr
{
public:
    // 생성자, 복사 생성자, 이동 생성자
    TSharedPtr() { }
    TSharedPtr(T* ptr) { Set(ptr); }
    TSharedPtr(const TSharedPtr& rhs) { Set(rhs._ptr); }
    TSharedPtr(TSharedPtr&& rhs) { _ptr = rhs._ptr; rhs._ptr = nullptr; }
    
    // 소멸자
    ~TSharedPtr() { Release(); }
    
    // 연산자 오버로딩
    TSharedPtr& operator=(const TSharedPtr& rhs);
    TSharedPtr& operator=(TSharedPtr&& rhs);
    bool operator==(const TSharedPtr& rhs) const;
    // ... 기타 연산자들 ...
    
    // 유틸리티 함수
    bool isNull() { return _ptr == nullptr; }
    
private:
    // 내부 구현 함수
    void Set(T* ptr);
    void Release();
    
    T* _ptr = nullptr;
};
```

- 자동으로 참조 카운팅을 관리하는 스마트 포인터입니다.
- `std::shared_ptr`와 유사한 기능을 제공합니다.
- 객체가 더 이상 필요하지 않을 때 자동으로 메모리를 해제합니다.

## 컨테이너 재정의

프로젝트에서 사용하는 STL 컨테이너들을 사용자 정의 할당자를 사용하도록 재정의합니다.

```cpp
template<typename Type>
using Vector = vector<Type, StlAllocator<Type>>;

template<typename Type>
using List = list<Type, StlAllocator<Type>>;

template<typename Key, typename Type, typename Pred = less<Key>>
using Map = map<Key, Type, Pred, StlAllocator<pair<const Key, Type>>>;

// ... 기타 컨테이너들 ...
```

- 모든 STL 컨테이너가 프로젝트의 메모리 할당 정책을 따르도록 합니다.
- 메모리 누수나 단편화 문제를 줄이는 데 도움이 됩니다.

## 메모리 관리의 중요성

1. **메모리 누수 방지**: 스마트 포인터와 RAII(Resource Acquisition Is Initialization) 패턴을 사용하여 메모리 누수를 방지합니다.
2. **디버깅 용이성**: 디버그 모드에서 특수 할당자를 사용하여 메모리 문제를 조기에 발견합니다.
3. **성능 최적화**: 커스텀 할당자를 통해 특정 사용 패턴에 최적화된 메모리 관리가 가능합니다.
4. **일관성**: 프로젝트 전체에서 일관된 메모리 관리 정책을 적용할 수 있습니다.

## 주의사항

1. 참조 순환(Circular Reference)에 주의해야 합니다. 두 객체가 서로를 참조하면 메모리 누수가 발생할 수 있습니다.
2. 스마트 포인터를 사용할 때는 소유권(ownership)을 명확히 해야 합니다.
3. 스레드 안전성을 고려해야 합니다. `atomic<int32>`를 사용하여 참조 카운트의 스레드 안전성을 보장합니다.

## 결론

메모리 관리는 C++ 프로그래밍에서 가장 중요한 측면 중 하나입니다. 이 문서에서 설명한 기법들을 사용하면 메모리 관련 버그를 줄이고 안정적인 프로그램을 작성하는 데 도움이 됩니다.
