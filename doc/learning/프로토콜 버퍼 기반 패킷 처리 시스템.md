# 프로토콜 버퍼 기반 패킷 처리 시스템

이 문서에서는 CPPServer 프로젝트에 도입된 프로토콜 버퍼(Protocol Buffers) 기반의 패킷 처리 시스템에 대해 설명합니다. 프로토콜 버퍼를 사용하여 어떻게 효율적으로 데이터를 직렬화하고, 네트워크를 통해 전송하며, 이를 처리하는지에 대한 전반적인 구조와 주요 구성 요소를 다룹니다.

## 1. 프로토콜 버퍼 (Protocol Buffers) 란?

프로토콜 버퍼는 Google에서 개발한 언어 및 플랫폼에 중립적인 직렬화 메커니즘입니다. XML과 유사하지만 더 작고, 빠르며, 간단합니다. `.proto`라는 특별한 언어로 데이터 구조를 한 번 정의하면, 생성된 소스 코드를 사용하여 다양한 언어(C++, Java, Python 등)에서 구조화된 데이터를 쉽게 읽고 쓸 수 있습니다.

**주요 장점:**
-   **효율성:** XML이나 JSON보다 데이터 크기가 작고 파싱 속도가 빠릅니다.
-   **강력한 타입 시스템:** 컴파일 시점에 타입 체크가 가능하여 런타임 오류를 줄일 수 있습니다.
-   **하위 호환성 및 상위 호환성:** 기존 데이터 구조에 새로운 필드를 추가해도 이전 버전의 코드가 문제없이 작동합니다.
-   **언어 중립성:** 다양한 프로그래밍 언어를 지원합니다.

## 2. 프로젝트 내 `.proto` 파일 정의

프로젝트에서는 `Protocol.proto` (또는 유사한 이름의 파일)에 클라이언트와 서버 간에 주고받을 메시지 구조를 정의합니다.

**예시 (`Protocol.proto` - proto3 syntax):**
```protobuf
syntax = "proto3"; // proto3 문법 사용 명시
package Protocol;

// 로그인 요청 메시지
message C_LOGIN {
  string id = 1;
  string password = 2;
}

// 로그인 응답 메시지
message S_LOGIN_RESULT {
  bool success = 1;
  string message = 2;
  int64 user_id = 3;
}

// 채팅 메시지
message C_CHAT {
  string message = 1;
}

message S_CHAT {
  int64 player_id = 1;
  string message = 2;
}

// 추가적인 메시지 타입들...
```

**주요 특징 (proto3):**
-   `syntax = "proto3";`로 시작하여 proto3 문법을 사용함을 명시합니다.
-   필드에 `optional` 이나 `required` 키워드를 기본적으로 사용하지 않습니다. 모든 단일 필드(repeated가 아닌 필드)는 기본적으로 optional과 유사하게 동작하며, 값이 설정되지 않으면 해당 타입의 기본값(숫자는 0, 문자열은 빈 문자열, bool은 false 등)을 가집니다.
-   `repeated` 키워드는 필드가 0개 이상의 값을 가질 수 있는 배열(리스트)임을 나타냅니다.
-   각 필드 뒤의 `= 1`, `= 2` 등은 필드 번호로, 바이너리 인코딩 시 필드를 식별하는 데 사용됩니다. 필드 번호 1-15는 인코딩 시 1바이트를 덜 차지하므로 자주 사용되거나 repeated 필드에 할당하는 것이 좋습니다.

이 `.proto` 파일을 프로토콜 버퍼 컴파일러(`protoc`)를 사용하여 C++ 코드로 변환합니다 (`Protocol.pb.h` 및 `Protocol.pb.cc`). 이 생성된 코드는 실제 메시지 객체를 생성하고, 직렬화/역직렬화하는 데 사용됩니다.

## 3. `BufferReader` 와 `BufferWriter`

생성된 프로토콜 버퍼 객체를 네트워크로 전송하거나 수신한 데이터를 파싱하기 위해 `SendBuffer` 및 `RecvBuffer`와 함께 사용될 `BufferReader`와 `BufferWriter` 클래스가 도입되었습니다.

-   **`BufferWriter`**: 프로토콜 버퍼 메시지 객체를 `SendBuffer`에 직렬화하여 쓰기 위한 유틸리티 클래스입니다. 메시지 ID와 실제 메시지 데이터를 버퍼에 순차적으로 기록합니다. 내부적으로 프로토콜 버퍼 메시지 객체의 `SerializeToArray(void* data, int size)` 또는 `SerializeToString(string* output)`과 같은 메서드를 사용하여 직렬화합니다.
    ```cpp
    // 예시: S_LOGIN_RESULT 메시지를 SendBuffer에 쓰기
    Protocol::S_LOGIN_RESULT pkt;
    pkt.set_success(true);
    pkt.set_message("Login successful!");
    pkt.set_user_id(1001);

    auto sendBuffer = ClientPacketHandler::MakeSendBuffer(pkt); // 내부적으로 BufferWriter 사용
    // sendBuffer를 소켓을 통해 전송
    ```

-   **`BufferReader`**: `RecvBuffer`로부터 데이터를 읽어 프로토콜 버퍼 메시지 객체로 역직렬화하기 위한 유틸리티 클래스입니다. 버퍼에서 메시지 ID를 먼저 읽고, 해당 ID에 맞는 메시지 타입으로 나머지 데이터를 파싱합니다. 내부적으로 프로토콜 버퍼 메시지 객체의 `ParseFromArray(const void* data, int size)` 또는 `ParseFromString(const string& data)`과 같은 메서드를 사용하여 역직렬화합니다.
    ```cpp
    // 예시: RecvBuffer에서 패킷 읽기 (실제 패킷 핸들러 내부 로직)
    // BufferHelper::RecvBufferPtr buffer; (수신된 데이터)
    // PacketHeader* header = reinterpret_cast<PacketHeader*>(buffer->ReadPos());
    // uint16 id = header->id;
    // uint16 size = header->size;
    // // ServerPacketHandler::HandlePacket 내부에서 BufferReader를 사용하거나 직접 파싱
    // // 예: Protocol::C_LOGIN loginPkt; loginPkt.ParseFromArray(payload, payloadSize);
    ```

## 4. 패킷 핸들러 (`ClientPacketHandler`, `ServerPacketHandler`)

수신된 패킷을 종류별로 구분하여 적절한 처리를 수행하기 위해 패킷 핸들러 클래스가 사용됩니다. 이 핸들러들은 프로토콜 버퍼 컴파일러(`protoc`)가 생성한 C++ 클래스의 메서드들을 활용하여 메시지 데이터를 읽고 씁니다. (예: `set_필드명()`, `필드명()`, `has_필드명()`, `clear_필드명()`, `mutable_필드명()`, `add_필드명()`, `필드명_size()`).

-   **`ServerPacketHandler` (서버 측):** 클라이언트로부터 `C_LOGIN`, `C_CHAT` 등의 요청 패킷을 받아 처리합니다.
    -   내부적으로 패킷 ID와 해당 패킷을 처리할 함수를 매핑하는 테이블(또는 `switch` 문)을 가집니다.
    -   `MakeSendBuffer`와 같은 정적 유틸리티 함수를 제공하여 응답 패킷 생성을 돕습니다.
    -   각 핸들러 함수는 역직렬화된 패킷 객체를 받아 비즈니스 로직을 수행하고, 필요한 경우 응답 패킷을 생성하여 클라이언트에 전송합니다.

    ```cpp
    // ServerPacketHandler.h 예시 (일부)
    class ServerPacketHandler {
    public:
        static void Init();
        static bool HandlePacket(GameSessionRef& session, BYTE* buffer, int32 len);
        static SendBufferRef MakeSendBuffer(Protocol::S_LOGIN_RESULT& pkt) { /* ... */ }
        // ... 다른 MakeSendBuffer 오버로딩

    private:
        // ...
        static bool Handle_C_LOGIN(GameSessionRef& session, Protocol::C_LOGIN& pkt);
        // {
        //     // 예: std::string userId = pkt.id();
        //     // 로직 처리 ...
        //     // Protocol::S_LOGIN_RESULT resPkt;
        //     // resPkt.set_success(true); ...
        //     // session->Send(MakeSendBuffer(resPkt));
        // }
        static bool Handle_C_CHAT(GameSessionRef& session, Protocol::C_CHAT& pkt);
        // ... 다른 핸들러 함수들
    };
    ```

-   **`ClientPacketHandler` (클라이언트 측):** 서버로부터 `S_LOGIN_RESULT`, `S_CHAT` 등의 응답/이벤트 패킷을 받아 처리합니다.
    -   `ServerPacketHandler`와 유사한 구조를 가집니다.

## 5. 패킷 처리 흐름

1.  **송신 측 (예: 클라이언트가 서버로 `C_LOGIN` 전송):**
    1.  `Protocol::C_LOGIN` 객체를 생성하고 `set_id()`, `set_password()` 등으로 데이터를 채웁니다.
    2.  `ClientPacketHandler::MakeSendBuffer(loginPkt)`를 호출하여 `SendBuffer`를 생성합니다.
        -   이 내부에서는 `BufferWriter`를 사용하여 패킷 헤더(크기, ID)와 직렬화된 `loginPkt` 데이터를 `SendBuffer`에 씁니다. (예: `loginPkt.SerializeToArray()`)
    3.  생성된 `SendBuffer`를 소켓을 통해 서버로 전송합니다.

2.  **수신 측 (예: 서버가 클라이언트로부터 `C_LOGIN` 수신):**
    1.  소켓으로부터 데이터를 `RecvBuffer`로 수신합니다.
    2.  `RecvBuffer`에서 패킷 헤더를 읽어 패킷의 크기와 ID(`PKT_C_LOGIN`)를 알아냅니다.
    3.  `ServerPacketHandler::HandlePacket(session, payloadBuffer, payloadLen)`를 호출합니다.
        -   `HandlePacket` 내부에서는 패킷 ID에 따라 `Handle_C_LOGIN` 함수를 호출합니다.
        -   `Handle_C_LOGIN` 함수로 전달하기 전에, `BufferReader` (또는 직접 파싱)를 사용하여 `payloadBuffer`로부터 `Protocol::C_LOGIN` 객체로 역직렬화합니다. (예: `loginPkt.ParseFromArray()`)
    4.  `Handle_C_LOGIN` 함수는 역직렬화된 `loginPkt` 객체의 필드(`loginPkt.id()`, `loginPkt.password()`)를 사용하여 로그인 로직을 처리하고, 필요시 `S_LOGIN_RESULT` 응답 패킷을 만들어 클라이언트에 전송합니다.

## 6. 주요 API 및 유의사항

프로토콜 버퍼를 C++에서 효과적으로 사용하기 위해 알아두면 좋은 몇 가지 사항이 있습니다.

-   **생성된 접근자 메서드:** `.proto` 파일에 정의된 각 필드에 대해 `protoc` 컴파일러는 다양한 접근자 메서드(getter/setter 등)를 생성합니다.
    -   `set_필드명(value)`: 필드 값을 설정합니다.
    -   `필드명()`: 필드 값을 가져옵니다 (const 버전).
    -   `has_필드명()`: (proto2에서 주로 사용, proto3에서는 존재 여부 확인 로직이 다를 수 있음. 일반적으로 기본값과 다른지 확인) 필드 값이 명시적으로 설정되었는지 확인합니다.
    -   `clear_필드명()`: 필드 값을 기본값으로 초기화합니다.
    -   `mutable_필드명()`: 문자열이나 메시지 타입 필드의 경우, 수정 가능한 포인터를 반환합니다.
    -   `add_필드명()`: `repeated` 필드에 새 항목을 추가하고 해당 항목에 대한 포인터를 반환합니다.
    -   `필드명_size()`: `repeated` 필드의 요소 개수를 반환합니다.

-   **라이브러리 버전 확인 및 초기화/종료:**
    -   애플리케이션 시작 시 `GOOGLE_PROTOBUF_VERIFY_VERSION;` 매크로를 호출하여 컴파일 시 사용된 헤더 파일 버전과 링크된 라이브러리 버전이 호환되는지 확인하는 것이 좋습니다.
    -   애플리케이션 종료 시 `google::protobuf::ShutdownProtobufLibrary();` 함수를 호출하여 프로토콜 버퍼 라이브러리가 할당한 전역 객체들을 해제할 수 있습니다. 이는 메모리 누수 탐지 도구를 사용할 때 유용할 수 있습니다.

    ```cpp
    // main.cpp 예시
    #include "protocol.pb.h" // 생성된 헤더
    // ...
    int main(int argc, char* argv[]) {
        GOOGLE_PROTOBUF_VERIFY_VERSION;
        // ... 애플리케이션 로직 ...
        google::protobuf::ShutdownProtobufLibrary();
        return 0;
    }
    ```

## 7. 결론

프로토콜 버퍼를 기반으로 한 패킷 처리 시스템은 타입 안정성, 효율성, 그리고 유지보수 용이성을 제공합니다. `BufferReader/Writer`와 패킷 핸들러를 통해 패킷 생성 및 처리 로직을 표준화하고 중앙 집중화하여 코드의 가독성과 확장성을 높입니다.
