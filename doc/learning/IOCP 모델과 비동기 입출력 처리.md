# IOCP 모델과 비동기 입출력 처리

## 1. IOCP (Input/Output Completion Port) 개요

IOCP는 Windows 운영체제에서 고성능 네트워크 프로그래밍을 위해 제공하는 비동기 입출력 모델입니다. 소수의 스레드로 다수의 클라이언트 연결을 효율적으로 관리할 수 있게 해주어, 서버의 확장성과 응답성을 크게 향상시킵니다.

주요 특징:
- **비동기 처리**: 입출력 작업이 완료될 때까지 스레드가 대기하지 않고 다른 작업을 수행할 수 있습니다.
- **스레드 풀링**: 미리 생성된 워커 스레드 풀을 사용하여 입출력 완료 이벤트를 처리합니다. 이를 통해 스레드 생성 및 소멸에 드는 오버헤드를 줄입니다.
- **확장성**: 동시에 처리할 수 있는 활성 스레드 수를 제한하여 컨텍스트 스위칭 비용을 최소화하고, CPU 코어 수에 맞춰 최적의 성능을 낼 수 있도록 합니다.
- **패킷 큐와 스레드 처리 순서**: 완료된 I/O 작업에 대한 패킷은 IOCP 큐에 FIFO(First-In, First-Out) 순서로 추가됩니다. 그러나 `GetQueuedCompletionStatus` 함수를 호출하여 대기 중이던 스레드들은 LIFO(Last-In, First-Out) 순서로 깨어나 이 패킷을 처리합니다. 즉, 가장 최근에 대기를 시작한 스레드가 가장 오래된 완료 패킷을 가져가게 됩니다.

## 2. CPPServer 프로젝트에서의 IOCP 구현 요소

CPPServer 프로젝트에서는 IOCP 모델을 활용하기 위해 다음과 같은 주요 클래스들을 도입했습니다:

### `IocpCore`
- IOCP 객체의 핵심 로직을 담당합니다.
- `CreateIoCompletionPort()` API를 사용하여 IOCP 핸들을 생성하고 관리합니다. 이때, 동시에 실행될 수 있는 스레드의 최대 수인 'Concurrency 값'을 설정합니다. 일반적으로 이 값은 시스템의 CPU 코어 수로 설정하는 것이 권장됩니다.
- 워커 스레드를 생성하고, 이 스레드들이 `GetQueuedCompletionStatus()` 함수를 호출하여 완료된 입출력 작업을 가져와 처리하도록 합니다.
- `PostQueuedCompletionStatus()` 함수를 사용하여 I/O 작업 완료 외의 사용자 정의 이벤트를 IOCP 큐에 추가하여 워커 스레드에게 알릴 수도 있습니다.

### `IocpEvent` (또는 유사한 이벤트 객체)
- 비동기 입출력 작업의 컨텍스트를 담는 객체입니다. `OVERLAPPED` 구조체를 확장하여 사용하며, 작업 유형(예: Accept, Receive, Send)과 관련된 데이터를 포함합니다.
- `WSASend`, `WSARecv` 등의 비동기 함수 호출 시 이 객체가 전달되며, 작업 완료 시 IOCP 큐를 통해 다시 전달받습니다.

### `Listener`
- 클라이언트의 연결 요청을 비동기적으로 수락하는 역할을 합니다.
- `AcceptEx()` 함수와 IOCP를 결합하여 새로운 클라이언트 연결을 효율적으로 처리합니다.
- 연결이 수락되면 새로운 `Session` 객체를 생성하고, 해당 세션의 소켓을 IOCP에 등록합니다.

### `Session`
- 각 클라이언트와의 통신 세션을 나타냅니다.
- 클라이언트 소켓과 관련된 데이터(예: 수신 버퍼, 송신 큐)를 관리합니다.
- `WSARecv`, `WSASend`를 사용하여 비동기적으로 데이터를 주고받으며, 이 작업들은 `IocpCore`를 통해 처리됩니다.
- 소켓이 IOCP에 등록되어 입출력 완료 이벤트가 발생하면, 해당 `Session` 객체의 메서드가 호출되어 데이터를 처리합니다.

## 3. IOCP 동작 흐름

1.  **초기화**:
    *   `IocpCore`는 IOCP 핸들을 생성하고, 지정된 수의 워커 스레드를 생성하여 대기시킵니다.
    *   `Listener`는 리슨 소켓을 생성하고, 클라이언트 연결 요청을 받을 준비를 합니다. `AcceptEx`를 위한 소켓들을 미리 준비하고 비동기 Accept를 시작합니다.
2.  **연결 수락**:
    *   클라이언트가 접속하면, `Listener`의 비동기 `AcceptEx` 작업이 완료됩니다.
    *   IOCP 큐를 통해 완료 이벤트가 워커 스레드에 전달됩니다.
    *   워커 스레드는 새로운 클라이언트 소켓에 대해 `Session` 객체를 생성하고, 이 소켓을 `IocpCore`에 등록합니다.
    *   새로운 `Session`에 대해 비동기 `WSARecv`를 호출하여 데이터 수신을 시작합니다.
3.  **데이터 송수신**:
    *   **수신**: 클라이언트로부터 데이터가 도착하면, 해당 `Session`에 대해 이전에 호출된 `WSARecv` 작업이 완료됩니다.
        *   IOCP 큐를 통해 완료 이벤트가 워커 스레드에 전달됩니다.
        *   워커 스레드는 `IocpEvent` (또는 `OVERLAPPED` 확장 구조체)를 통해 어떤 `Session`에서 어떤 작업이 완료되었는지 식별합니다.
        *   해당 `Session`의 데이터 처리 로직(예: 패킷 파싱)을 실행합니다.
        *   처리가 끝나면 다시 비동기 `WSARecv`를 호출하여 다음 데이터 수신을 준비합니다.
    *   **송신**: 서버가 클라이언트에게 데이터를 보내야 할 때, 해당 `Session`은 비동기 `WSASend`를 호출합니다.
        *   데이터 전송이 완료되면 IOCP 큐를 통해 완료 이벤트가 전달되고, 워커 스레드가 후속 처리를 합니다 (예: 송신 버퍼 정리).
4.  **연결 종료**:
    *   클라이언트 연결이 끊어지거나 서버가 연결을 종료해야 할 때, 관련된 소켓을 닫고 `Session` 객체를 정리합니다.
    *   `WSARecv`가 0바이트를 반환하거나 오류를 반환하면 연결 종료로 간주합니다.

## 4. IOCP 사용의 장점

- **고성능**: 적은 수의 스레드로 많은 동시 연결을 처리할 수 있어 시스템 리소스를 효율적으로 사용합니다.
- **응답성 향상**: 비동기 작업으로 인해 스레드가 블로킹되지 않아 다른 요청에 빠르게 응답할 수 있습니다.
- **서버 안정성**: 스레드 수를 제한하여 과도한 컨텍스트 스위칭으로 인한 성능 저하를 방지합니다.

## 5. 주의사항 및 고려사항

- **복잡성**: `select`나 `WSAEventSelect` 모델에 비해 구현이 복잡합니다. `OVERLAPPED` 구조체와 완료 루틴 관리에 주의해야 합니다.
- **에러 처리**: 비동기 작업의 에러 처리는 동기 모델보다 까다로울 수 있습니다. 각 작업 단계별로 철저한 에러 검사가 필요합니다.
- **자원 관리**: `Session` 객체, `IocpEvent` 객체 등의 라이프사이클 관리가 중요합니다. 메모리 누수나 이중 해제 문제가 발생하지 않도록 주의해야 합니다. `ObjectPool`을 활용하면 도움이 될 수 있습니다.
- **Concurrency 값 설정**: `CreateIoCompletionPort` 호출 시 `NumberOfConcurrentThreads` 파라미터(Concurrency 값) 설정이 중요합니다. 이 값은 동시에 실행될 수 있는 스레드 수를 제한하며, 일반적으로 CPU 코어 수로 설정하는 것이 좋습니다. 너무 작으면 CPU 활용률이 낮아지고, 너무 크면 컨텍스트 스위칭 오버헤드가 발생할 수 있습니다. 실제 애플리케이션의 특성에 맞게 테스트를 통해 최적값을 찾는 것이 중요합니다.
- **스레드 풀 관리**: Concurrency 값보다 많은 스레드를 스레드 풀에 생성해두는 것이 일반적입니다 (예: CPU 코어 수의 2배). 이는 일부 스레드가 I/O 작업이 아닌 다른 이유로 대기 상태에 빠질 경우를 대비하기 위함입니다.

이 문서는 CPPServer 프로젝트에 IOCP 모델을 도입하면서 핵심적인 개념과 구현 요소들을 정리한 것입니다. IOCP는 고성능 서버 개발에 필수적인 기술이므로, 관련 API와 동작 원리를 깊이 이해하는 것이 중요합니다.
