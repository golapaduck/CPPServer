# 논블로킹 소켓 프로그래밍 (Winsock)

논블로킹 소켓은 프로그램의 다른 부분을 멈추지 않고 네트워킹 작업을 수행할 수 있게 해주는 중요한 방식입니다. 이 문서에서는 Winsock API를 사용하여 C++에서 기본적인 논블로킹 TCP 클라이언트와 서버를 구현하는 방법을 설명합니다.

## 핵심 개념

- **블로킹 vs. 논블로킹 소켓:**
  - **블로킹 소켓:** `connect`, `accept`, `send`, `recv`와 같은 함수 호출 시, 작업이 완료될 때까지 프로그램 실행이 멈춥니다. 간단하지만, 대기 시간 동안 프로그램 전체가 멈출 수 있다는 단점이 있습니다.
  - **논블로킹 소켓:** 소켓 함수 호출 시 즉시 반환됩니다. 작업이 바로 완료되지 않으면, 특정 오류 코드(예: `WSAEWOULDBLOCK`)를 반환하며 프로그램은 다른 작업을 계속 수행할 수 있습니다. 주기적인 폴링이나 이벤트 기반 알림(예: `select`, `WSAAsyncSelect`, `WSAEventSelect`, IOCP)을 통해 작업 완료 여부를 확인해야 합니다.

- **`ioctlsocket`과 `FIONBIO`:**
  - 소켓을 논블로킹 모드로 설정하는 데 사용됩니다.
  - `u_long on = 1; ioctlsocket(socket, FIONBIO, &on);` 형태로 호출합니다.

- **`WSAEWOULDBLOCK`:**
  - 논블로킹 소켓에서 작업이 즉시 완료될 수 없을 때 반환되는 오류 코드입니다. 이 코드를 받으면, 나중에 다시 시도해야 합니다.

## 서버 측 (GameServer.cpp 예시)

1.  **WSAStartup:** Winsock 라이브러리를 초기화합니다.
2.  **소켓 생성 (`socket`):** 리스닝 소켓을 생성합니다.
3.  **논블로킹 모드 설정 (`ioctlsocket`):** 리스닝 소켓을 논블로킹으로 설정합니다.
4.  **주소 정보 설정 (`SOCKADDR_IN`):** 서버 주소 (IP, 포트)를 설정합니다.
5.  **소켓 바인딩 (`bind`):** 소켓에 주소 정보를 할당합니다.
6.  **리슨 (`listen`):** 클라이언트 연결 요청을 대기하도록 설정합니다.
7.  **클라이언트 접속 처리 루프 (`accept`):
    -   `accept` 함수를 호출하여 클라이언트 연결을 수락합니다.
    -   논블로킹 모드이므로 `accept`는 즉시 반환됩니다.
    -   성공하면 클라이언트 소켓을 얻고, 실패 시 `WSAEWOULDBLOCK`이면 재시도, 다른 오류면 처리합니다.
    -   새로 생성된 클라이언트 소켓도 일반적으로 논블로킹 모드로 설정하여 관리합니다 (예제에서는 리스닝 소켓만 논블로킹으로 설정했으나, 클라이언트 소켓도 동일하게 `ioctlsocket`으로 설정 가능).
8.  **데이터 수신/송신 루프 (`recv`, `send`):
    -   각 클라이언트 소켓에 대해 `recv`를 호출하여 데이터를 받습니다.
    -   `recv`가 `WSAEWOULDBLOCK`을 반환하면 아직 데이터가 도착하지 않은 것이므로 재시도합니다.
    -   데이터를 받으면, `send`를 호출하여 응답을 보냅니다.
    -   `send` 역시 `WSAEWOULDBLOCK`을 처리해야 합니다.
9.  **소켓 종료 (`closesocket`):** 통신이 끝난 소켓 리소스를 해제합니다.
10. **WSACleanup:** Winsock 라이브러리 사용을 종료합니다.

```cpp
// GameServer.cpp 주요 부분 (논블로킹 accept 예시)
// ... (WSAStartup, socket, ioctlsocket, bind, listen)
while (true)
{
    SOCKET clientSocket = ::accept(listenSocket, (SOCKADDR*)&clientAddr, &addrLen);
    if (clientSocket == INVALID_SOCKET)
    {
        if (::WSAGetLastError() == WSAEWOULDBLOCK)
            continue; // 아직 접속 요청 없음, 다른 작업 수행 또는 잠시 대기
        // 실제 오류 처리
        break;
    }
    cout << "Client Connected!" << endl;
    // 클라이언트 소켓으로 recv/send 처리 (이 부분도 논블로킹으로 구현)
}
```

## 클라이언트 측 (DummyClient.cpp 예시)

1.  **WSAStartup:** Winsock 라이브러리를 초기화합니다.
2.  **소켓 생성 (`socket`):** 통신할 소켓을 생성합니다.
3.  **논블로킹 모드 설정 (`ioctlsocket`):** 클라이언트 소켓을 논블로킹으로 설정합니다.
4.  **서버 주소 정보 설정 (`SOCKADDR_IN`):** 접속할 서버의 주소 (IP, 포트)를 설정합니다.
5.  **서버 접속 시도 (`connect`):**
    -   클라이언트 소켓이 논블로킹 모드로 설정된 후 `connect` 함수를 호출하여 서버에 접속을 시도합니다.
    -   `connect`는 즉시 반환됩니다. 대부분의 경우 `SOCKET_ERROR`를 반환하고 `WSAGetLastError()`가 `WSAEWOULDBLOCK`을 반환하는데, 이는 연결 절차가 백그라운드에서 진행 중임을 의미합니다.
    -   **연결 완료 확인:** `WSAEWOULDBLOCK`을 받은 후, 연결이 성공적으로 완료되었는지 확인해야 합니다. 가장 일반적인 방법은 `select()` 함수를 사용하는 것입니다.
        -   `select()` 함수에 클라이언트 소켓을 쓰기(write) 소켓 셋(set)과 예외(exception) 소켓 셋에 넣고 호출합니다.
        -   `select()`가 반환되면, 소켓이 쓰기 가능 상태인지 확인합니다. 쓰기 가능 상태가 되었다면 연결 시도가 성공했거나 실패했을 수 있습니다.
        -   연결 성공 여부를 최종적으로 확인하려면 `getsockopt()` 함수와 `SO_ERROR` 옵션을 사용하여 소켓의 오류 상태를 가져옵니다. `SO_ERROR`가 0이면 연결 성공, 다른 값이면 연결 실패입니다.
    -   만약 `connect` 호출 시 `WSAEISCONN` 오류가 반환되면, 해당 소켓은 이미 연결된 상태입니다. 드물게 `connect`가 즉시 성공하여 `0`을 반환할 수도 있습니다.
    -   **주의:** `WSAEWOULDBLOCK` 이후 단순히 `connect`를 반복 호출하는 것은 CPU 자원을 낭비하므로 피해야 합니다. `select()`와 같은 I/O 모델을 사용해야 합니다.
    -   (학습 문서의 아래 예제 코드는 `select`를 사용한 완전한 연결 확인 로직 대신, `WSAEWOULDBLOCK` 처리의 기본 개념만 보여주며, 실제 애플리케이션에서는 `select` 기반의 연결 확인이 필수적임을 강조합니다.)
6.  **데이터 송신/수신 루프 (`send`, `recv`):
    -   `send`를 호출하여 데이터를 보냅니다. `WSAEWOULDBLOCK`을 처리합니다.
    -   `recv`를 호출하여 데이터를 받습니다. `WSAEWOULDBLOCK`을 처리합니다.
7.  **소켓 종료 (`closesocket`):** 통신이 끝난 소켓 리소스를 해제합니다.
8.  **WSACleanup:** Winsock 라이브러리 사용을 종료합니다.

```cpp
// DummyClient.cpp 주요 부분 (논블로킹 connect 개념 예시)
// ... (WSAStartup, socket 생성, ioctlsocket으로 논블로킹 설정, serverAddr 설정)

// 서버에 접속 시도
if (::connect(clientSocket, (SOCKADDR*)&serverAddr, sizeof(serverAddr)) == SOCKET_ERROR)
{
    int errCode = ::WSAGetLastError();
    if (errCode == WSAEWOULDBLOCK)
    {
        // 연결이 진행 중입니다. (Non-blocking connect initiated)
        // 이 시점에서 프로그램은 다른 작업을 수행할 수 있습니다.
        // 이후, select() 함수를 사용하여 소켓이 쓰기 가능해질 때까지 기다린 후,
        // getsockopt(clientSocket, SOL_SOCKET, SO_ERROR, ...)를 호출하여
        // 연결 성공 여부(에러 코드 0)를 최종 확인해야 합니다.
        cout << "Connection attempt in progress (WSAEWOULDBLOCK)... Use select() to check completion." << endl;
    }
    else if (errCode == WSAEISCONN)
    {
        // 이미 연결된 상태 (예: 이전 호출에서 연결 성공 후 다시 connect 시도)
        cout << "Already connected." << endl;
    }
    else
    {
        // 그 외 연결 오류
        cout << "Connection failed with error: " << errCode << endl;
        // 오류 처리 (예: 소켓 닫기, WSACleanup)
        ::closesocket(clientSocket);
        ::WSACleanup();
        return; // 또는 적절한 오류 처리
    }
}
else
{
    // connect가 즉시 성공 (드문 경우, 주로 로컬 루프백 주소에 연결 시)
    cout << "Connected to Server immediately!" << endl;
}

// !!! 중요 !!!
// 위의 WSAEWOULDBLOCK 처리 이후, 실제 데이터 송수신 전에는
// select() 등을 이용한 연결 완료 확인 절차가 반드시 필요합니다.
// 이 예제에서는 해당 부분을 개념적으로 설명하고 생략합니다.

// 연결이 성공적으로 완료되었다고 가정하고 send/recv 로직 진행...
// (실제로는 select() 등으로 연결 완료를 확인한 후 진행해야 함)
// ... 이후 send/recv 처리 (이 부분도 논블로킹으로 구현) ...
```

## 장점

-   **응답성 향상:** 주 작업 스레드가 I/O 작업 대기로 멈추지 않아 사용자 인터페이스나 다른 중요한 로직이 계속 실행될 수 있습니다.
-   **많은 연결 처리 용이:** 단일 스레드 또는 적은 수의 스레드로도 여러 클라이언트 연결을 효율적으로 관리할 수 있는 기반이 됩니다 (보통 `select`, `epoll`, IOCP 등과 함께 사용).

## 고려 사항

-   **복잡성 증가:** 블로킹 소켓보다 코드 작성이 복잡해집니다. 작업 완료 여부를 계속 확인하거나, 이벤트 통지 메커니즘을 구현해야 합니다.
-   **자원 사용:** 부주의하게 반복적인 폴링(polling)을 사용하면 CPU 자원을 과도하게 소모할 수 있습니다.

이 문서는 Winsock을 사용한 기본적인 논블로킹 소켓의 개념과 간단한 구현 방법을 다룹니다. 실제 애플리케이션에서는 `select` 모델, `WSAAsyncSelect`, `WSAEventSelect` 또는 고성능 서버를 위한 IOCP(I/O Completion Port)와 같은 더 발전된 I/O 모델과 함께 사용되는 경우가 많습니다.
