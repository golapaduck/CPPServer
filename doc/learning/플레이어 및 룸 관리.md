# 학습 문서: 플레이어 및 룸 관리

## 1. 개요

본 문서는 CPPServer 프로젝트에 새롭게 추가된 플레이어(`Player`) 및 단일 전역 룸(`Room`) 관리 기능에 대해 설명합니다. 이 기능들은 게임 서버의 기본적인 사용자 관리 및 데이터 전파 구조를 나타내며, 향후 다중 룸 및 복잡한 상호작용의 기반이 될 수 있습니다. 현재 구현은 단일, 전역적으로 접근 가능한 `GRoom` 인스턴스를 사용합니다.

## 2. 주요 구성 요소

### 2.1. `Player` 클래스 (`Player.h`)

-   **역할**: 개별 클라이언트(플레이어)의 핵심 데이터와 해당 클라이언트의 `GameSession`에 대한 참조를 관리합니다.
-   **주요 멤버 변수**:
    -   `uint64 playerId`: 플레이어의 고유 식별자입니다.
    -   `string name`: 플레이어의 이름입니다. (현재 코드에서는 초기화/설정 로직 부재)
    -   `Protocol::PlayerType type`: 프로토콜에 정의된 플레이어의 타입입니다. (기본값: `PLAYER_TYPE_NONE`)
    -   `GameSessionRef ownerSession`: 이 `Player` 객체를 소유하고 있는 `GameSession`에 대한 스마트 포인터 (`std::shared_ptr`)입니다. 이를 통해 `Player` 객체는 자신과 연결된 세션으로 데이터를 전송할 수 있습니다.
-   **구현 특징**:
    -   `Player.cpp` 파일은 현재 비어 있으며, 모든 멤버는 헤더 파일에서 기본 초기화되거나 생성자에서 초기화될 것으로 예상됩니다.
    -   `GameSession`과 `Player` 간에는 상호 참조 관계가 형성될 수 있습니다 (`GameSession`이 `PlayerRef`를, `Player`가 `GameSessionRef`를 가짐).

### 2.2. `Room` 클래스 (`Room.h`, `Room.cpp`)

-   **역할**: 현재 시스템에서는 단일, 전역 `Room`(`GRoom`)으로 구현되어, 서버에 연결된 모든 플레이어들을 관리하고 이들에게 데이터를 일괄 전송(브로드캐스트)하는 기능을 수행합니다.
-   **주요 멤버 변수**:
    -   `map<uint64, PlayerRef> _players`: `playerId`를 키로, 해당 `Player` 객체에 대한 `PlayerRef`(스마트 포인터)를 값으로 가지는 맵입니다. 현재 룸에 참여 중인 플레이어들을 저장합니다.
-   **주요 멤버 함수**:
    -   `void Enter(PlayerRef player)`: 새로운 플레이어를 룸에 추가합니다. `_players` 맵에 `player->playerId`를 키로 하여 `player`를 저장합니다. `WRITE_LOCK`을 사용하여 동시 접근을 제어합니다.
    -   `void Leave(PlayerRef player)`: 플레이어를 룸에서 제거합니다. `_players` 맵에서 `player->playerId`에 해당하는 항목을 삭제합니다. `WRITE_LOCK`을 사용하여 동시 접근을 제어합니다.
    -   `void Broadcast(SendBufferRef sendBuffer)`: 룸에 있는 모든 플레이어에게 `sendBuffer`의 내용을 전송합니다. `_players` 맵을 순회하며 각 `Player`의 `ownerSession->Send()`를 호출합니다. `WRITE_LOCK`을 사용하여 동시 접근을 제어합니다. (주: 단순 순회 및 읽기 작업이라면 `READ_LOCK`이 더 적합할 수 있으나, `Send` 함수의 내부 동작에 따라 `WRITE_LOCK`이 필요할 수도 있습니다.)
-   **전역 인스턴스**:
    -   `extern Room GRoom;` (`Room.h`): `GRoom`이라는 `Room` 타입의 전역 객체가 있음을 선언합니다.
    -   `Room GRoom;` (`Room.cpp`): `GRoom` 전역 객체를 정의합니다.
-   **동기화**:
    -   `USE_LOCK` 매크로 (`Room.h` 내): `Room` 클래스가 락 메커니즘을 사용함을 나타냅니다. (구체적인 락 타입은 `Lock.h` 등 관련 헤더에 정의되어 있을 것으로 추정되며, 일반적으로 `std::mutex` 또는 `SRWLock` 등을 캡슐화한 커스텀 락일 가능성이 높습니다.)
    -   `WRITE_LOCK` 매크로 (`Room.cpp` 내): `Enter`, `Leave`, `Broadcast` 함수 내부에서 쓰기 잠금을 획득하는 데 사용됩니다. `std::map`은 자체적으로 스레드 안전성을 보장하지 않으므로 이러한 외부 동기화 메커니즘이 필수적입니다.

## 3. 주요 상호작용 흐름 (예상)

1.  클라이언트가 서버에 접속하면 `GameSession` 객체가 생성됩니다.
2.  인증 또는 플레이어 생성 로직을 통해 `Player` 객체가 생성되고, 해당 `GameSession`과 연결됩니다 (`player->ownerSession` 설정, `gameSession->_player` 설정).
3.  생성된 `Player` 객체는 `GRoom.Enter(player)`를 통해 전역 룸에 입장합니다.
4.  서버가 특정 내용을 모든 플레이어에게 알려야 할 경우, `GRoom.Broadcast(sendBuffer)`를 호출합니다.
5.  클라이언트 연결이 종료되거나 플레이어가 게임을 떠날 때, `GRoom.Leave(player)`를 호출하여 룸에서 해당 플레이어를 제거합니다.
6.  `ClientPacketHandler`는 클라이언트로부터 수신한 패킷을 분석하여, 플레이어의 상태 변경이나 특정 액션 요청 시 `Player` 객체의 정보를 수정하거나 `GRoom`의 기능을 활용할 수 있습니다.

## 4. 기대 효과 및 고려 사항

-   **기대 효과**:
    -   중앙화된 플레이어 관리 및 브로드캐스트 메커니즘을 제공합니다.
    -   코드 구조를 단순화하여 기본적인 멀티플레이어 기능을 빠르게 구현할 수 있습니다.
-   **고려 사항**:
    -   **단일 룸의 한계**: 현재 `GRoom`은 단일 전역 룸으로, 모든 플레이어가 같은 공간에 있는 것으로 간주됩니다. 향후 다양한 게임 채널, 인스턴스 던전 등 독립적인 다중 룸을 지원하려면 `Room` 관리 시스템의 확장이 필요합니다. (예: `RoomManager` 클래스 도입, `Room` 객체 동적 생성 및 관리)
    -   **락 범위 및 성능**: `Broadcast` 함수에서 `WRITE_LOCK`을 사용하는 것은 모든 플레이어에 대한 `Send` 작업이 완료될 때까지 룸 상태 변경(새 플레이어 입장/퇴장)을 막습니다. 플레이어 수가 많을 경우 병목 현상이 발생할 수 있습니다. 각 세션의 `Send`가 스레드 안전하고 룸의 상태를 변경하지 않는다면, 플레이어 목록을 안전하게 복사한 후 락을 해제하고 `Send`를 호출하거나, `std::shared_mutex`와 같은 읽기/쓰기 락을 사용하여 `Broadcast` 중에는 읽기 잠금(`READ_LOCK`)을 사용하는 것을 고려할 수 있습니다.
    -   **플레이어 이름/타입**: `Player` 클래스의 `name`과 `type` 멤버는 현재 코드에서 설정되거나 사용되는 부분이 명확하지 않습니다. 관련 패킷 처리 로직에서 이 값들이 채워지고 활용될 것으로 예상됩니다.
