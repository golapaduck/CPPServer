# 오브젝트 풀 (Object Pool)

## 1. 개요

오브젝트 풀은 자주 사용되는 객체들을 미리 생성하여 풀(pool)에 보관하고, 필요할 때마다 이 풀에서 객체를 가져다 쓰고 사용 후에는 다시 풀에 반납하는 메모리 관리 디자인 패턴입니다. 객체의 반복적인 생성과 소멸에 드는 오버헤드를 줄여 애플리케이션의 성능을 향상시키는 것이 주 목적입니다. 특히, 동일한 타입의 객체를 빈번하게 생성하고 해제해야 하는 시스템(예: 게임 엔진, 네트워크 서버 등)에서 효과적입니다.

## 2. `ObjectPool<Type>` 클래스 분석

제공된 `ObjectPool.h` 코드는 특정 타입 `Type`의 객체들을 관리하는 템플릿 클래스입니다.

### 주요 구성 요소:

-   **`template<typename Type>`**: 클래스가 특정 타입에 국한되지 않고, 다양한 타입의 객체를 관리할 수 있도록 템플릿으로 정의되었습니다.
-   **`static MemoryPool s_pool`**: 내부적으로 `MemoryPool` 타입의 정적 멤버 변수 `s_pool`을 사용하여 객체가 실제로 저장될 메모리 블록들을 관리합니다. 각 `ObjectPool<Type>` 템플릿 인스턴스화마다 고유한 `MemoryPool` 객체가 생성됩니다. (즉, `ObjectPool<MyClass1>`과 `ObjectPool<MyClass2>`는 별도의 메모리 풀을 가집니다.)
-   **`static int32 s_allocSize`**: 각 객체를 풀에 저장하는 데 필요한 실제 메모리 할당 크기입니다. 이 크기는 `sizeof(Type) + sizeof(MemoryHeader)`로 계산됩니다. 즉, 순수 객체의 크기뿐만 아니라, 메모리 풀에서 이 객체를 관리하기 위한 추가 정보(메모리 헤더)까지 포함한 크기입니다.

### 주요 메서드:

1.  **`Pop(Args&&... args)` (static 메서드)**
    -   오브젝트 풀에서 사용 가능한 객체(정확히는 객체를 생성할 메모리)를 가져옵니다.
    -   내부적으로 `s_pool.Pop()`을 호출하여 메모리 풀로부터 미리 할당된 메모리 블록을 가져옵니다.
    -   `#ifdef _STOMP` 전처리기 지시문은 메모리 오버런/언더런 등의 오류를 감지하는 디버깅 기법인 "Stomp Allocator"의 사용 여부를 나타냅니다. 이것이 정의되어 있다면, 표준 메모리 풀 대신 `StompAllocator`를 통해 메모리를 할당받습니다.
    -   가져온 메모리 블록의 주소(`memory`)에 **placement new** 문법 (`new(memory)Type(std::forward<Args>(args)...);`)을 사용하여 객체를 생성(초기화)합니다.
        -   **Placement new**: 이미 할당된 메모리 위치에 객체를 생성하는 방법입니다. 일반 `new`와 달리 추가적인 메모리 할단을 수행하지 않습니다.
        -   **`std::forward<Args>(args)...`**: 인자로 전달받은 `args`를 객체의 생성자로 "완벽하게 전달(perfect forwarding)"합니다. 이를 통해 인자의 값 카테고리(lvalue 또는 rvalue)가 보존되어, 불필요한 복사를 피하고 이동 의미론(move semantics)을 올바르게 활용할 수 있습니다.
    -   생성된 객체의 포인터를 반환합니다.

2.  **`Push(Type* obj)` (static 메서드)**
    -   사용이 끝난 객체를 오브젝트 풀에 반납합니다.
    -   먼저 객체의 소멸자 (`obj->~Type();`)를 명시적으로 호출합니다. Placement new로 생성된 객체는 자동으로 소멸자가 호출되지 않으므로, 반드시 수동으로 호출하여 객체가 사용하던 리소스를 정리해야 합니다.
    -   `#ifdef _STOMP`가 정의되어 있다면, `StompAllocator`를 통해 메모리를 해제합니다.
    -   그렇지 않으면 `s_pool.Push()`를 호출하여 객체가 사용하던 메모리 블록을 내부 메모리 풀에 반납하여 재사용될 수 있도록 합니다.

3.  **`MakeShared()` (static 메서드)**
    -   오브젝트 풀에서 관리되는 객체에 대한 `std::shared_ptr`를 생성하여 반환합니다.
    -   `std::shared_ptr`을 생성할 때, 두 번째 인자로 **커스텀 삭제자(custom deleter)**를 전달합니다. 여기서는 `Push` 메서드의 함수 포인터(`Push`)가 커스텀 삭제자로 사용됩니다.
    -   커스텀 삭제자를 사용하면 `shared_ptr`의 참조 카운트가 0이 되어 객체가 더 이상 필요 없어질 때, 기본 `delete` 연산자 대신 지정된 `Push` 함수가 호출됩니다. 결과적으로, `shared_ptr`가 소멸될 때 객체가 자동으로 풀에 반납되어 메모리 관리가 편리해지고 누수 위험이 줄어듭니다.

### 사용 예시 (추정)

```cpp
// 예시 타입
struct MyObject {
    int id;
    std::string data;

    MyObject(int val, const std::string& str) : id(val), data(str) {
        std::cout << "MyObject(" << id << ", \"" << data << "\") 생성\n";
    }
    ~MyObject() {
        std::cout << "MyObject(" << id << ", \"" << data << "\") 소멸\n";
    }
    void Print() {
        std::cout << "ID: " << id << ", Data: " << data << std::endl;
    }
};

// 오브젝트 풀 사용
MyObject* obj1 = ObjectPool<MyObject>::Pop(10, "Hello");
if (obj1) {
    obj1->Print();
    ObjectPool<MyObject>::Push(obj1); // 명시적 반납
}

// MakeShared 사용
{
    std::shared_ptr<MyObject> obj2 = ObjectPool<MyObject>::MakeShared(20, "World");
    if (obj2) {
        obj2->Print();
    }
} // obj2의 스코프가 끝나면 참조 카운트가 0이 되고, 커스텀 삭제자인 Push가 호출되어 풀에 자동 반납됨
```

## 3. 장점

-   **성능 향상**: 객체 생성(메모리 할당 및 생성자 호출)과 소멸(소멸자 호출 및 메모리 해제)에 드는 반복적인 비용을 크게 줄일 수 있습니다. 특히 생성/소멸 비용이 큰 객체일수록 효과가 큽니다.
-   **메모리 단편화 감소**: 시스템 전역 힙(heap)에서 빈번하게 작은 크기의 메모리를 할당하고 해제하는 대신, 미리 큰 덩어리의 메모리 풀을 할당받아 사용하므로 메모리 단편화 문제를 완화할 수 있습니다. (이는 `MemoryPool`의 내부 구현에 따라 달라질 수 있습니다.)
-   **메모리 관리 용이성 증대**: `MakeShared`와 같이 스마트 포인터와 커스텀 삭제자를 결합하면, 객체의 반납을 자동화하여 개발자의 실수를 줄이고 메모리 누수 위험을 낮출 수 있습니다.

## 4. 고려 사항

-   **풀 크기 관리**:
    -   **초기 크기**: 애플리케이션 시작 시 풀에 몇 개의 객체를 미리 생성해 둘 것인가?
    -   **최대 크기**: 풀이 가질 수 있는 객체의 최대 개수는 얼마로 제한할 것인가? 풀이 가득 찼을 때 추가 요청은 어떻게 처리할 것인가 (예: 대기, 에러 반환, 동적 확장)?
    -   **동적 확장/축소**: 사용량에 따라 풀의 크기를 동적으로 조절할 것인가? (현재 제공된 `ObjectPool` 코드는 내부 `MemoryPool`의 정책에 따라 달라지며, `MemoryPool`이 동적 확장을 지원한다면 `ObjectPool`도 그럴 것입니다.)
-   **스레드 안전성 (Thread Safety)**:
    -   멀티스레드 환경에서 여러 스레드가 동시에 `Pop`이나 `Push` 메서드에 접근할 경우, 데이터 경쟁(data race)이 발생하여 풀의 상태가 망가질 수 있습니다.
    -   이를 방지하기 위해 `Pop`과 `Push` 연산, 그리고 내부 `MemoryPool`의 연산들이 스레드 안전하게 구현되어야 합니다. 일반적인 방법으로는 뮤텍스(mutex)를 사용하여 임계 영역(critical section)을 보호하거나, 락프리(lock-free) 자료구조를 사용하는 방법이 있습니다. (현재 `ObjectPool` 코드만으로는 스레드 안전성을 단정할 수 없으며, 내부 `MemoryPool`의 구현에 크게 의존합니다.)
-   **객체 상태 초기화**: 풀에서 객체를 가져와 사용할 때, 이전에 사용되었던 상태가 남아있지 않도록 주의해야 합니다. `Pop`에서 placement new를 통해 생성자를 호출하므로 객체는 항상 새롭게 초기화됩니다. `Push`에서는 소멸자를 호출하여 객체가 사용한 리소스를 정리합니다.
-   **Overhead**: 오브젝트 풀 자체가 약간의 관리 오버헤드를 가집니다. 매우 가볍고 빠르게 생성/소멸되는 객체에는 오히려 성능 저하를 일으킬 수도 있으므로, 적용 대상과 상황을 잘 고려해야 합니다.
